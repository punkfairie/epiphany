"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;
exports.ruleName = exports.messages = void 0;
var _stylelint = require("stylelint");
var _isStandardSyntaxRule = _interopRequireDefault(require("stylelint/lib/utils/isStandardSyntaxRule"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var deepFlatten = function deepFlatten(arr) {
  var _ref;
  return (_ref = []).concat.apply(_ref, _toConsumableArray(arr.map(function (v) {
    return Array.isArray(v) ? deepFlatten(v) : v;
  })));
};
var ruleName = 'a11y/selector-pseudo-class-focus';
exports.ruleName = ruleName;
var messages = _stylelint.utils.ruleMessages(ruleName, {
  expected: function expected(value) {
    return "Expected that ".concat(value, " is used together with :focus pseudo-class");
  }
});
exports.messages = messages;
function hasAlready(parent, repalcedSelector, selector) {
  var nodes = parent.nodes.map(function (i) {
    if (i.type === 'rule') return i.selectors;
  });
  var hoveredSelector = selector.split(',').filter(function (o) {
    return o.match(/:hover/gi);
  }).map(function (o) {
    return o.trim();
  });
  var returned = hoveredSelector.some(function (o) {
    return deepFlatten(nodes).indexOf(o.replace(/:hover/gi, ':focus')) >= 0;
  });
  if (returned) return true;
  return parent.nodes.some(function (i) {
    return i.type === 'rule' && i.selectors.indexOf(repalcedSelector) !== -1;
  });
}
function _default(actual, _, context) {
  return function (root, result) {
    var validOptions = _stylelint.utils.validateOptions(result, ruleName, {
      actual: actual
    });
    if (!validOptions || !actual) {
      return;
    }
    root.walkRules(function (rule) {
      var selector = null;
      if (!(0, _isStandardSyntaxRule["default"])(rule)) {
        return;
      }
      selector = rule.selector;
      if (!selector) {
        return;
      }
      if (selector.indexOf(':') === -1) {
        return;
      }
      if (selector.indexOf(':hover') === -1) {
        return;
      }
      if (selector.indexOf(':hover') >= 0 && selector.indexOf(':focus') >= 0) {
        return;
      }
      var isAccepted = hasAlready(rule.parent, selector.replace(/:hover/g, ':focus'), selector);
      if (context.fix && !isAccepted) {
        rule.parent.nodes.forEach(function (node) {
          if (node.type === 'rule' && node.selector === selector) {
            node.selector = "".concat(node.selector, ", ").concat(node.selector.replace(/:hover/g, ':focus'));
          }
        });
        return;
      }
      if (!isAccepted) {
        _stylelint.utils.report({
          index: rule.lastEach,
          message: messages.expected(selector),
          node: rule,
          ruleName: ruleName,
          result: result
        });
      }
    });
  };
}